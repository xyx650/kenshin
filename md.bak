/****************
 * 忽略清单
 ****************/
const ignoresMap = {
  // 'config-provider': ['index', 'demo'],
  overview: ['index'],
  // form: ['demo', 'index'],

  button: ['index', 'basic'],
  input: ['index', 'basic'],
  slider: ['index', 'basic']
}


const fs = require('fs')
let args = process.argv.slice(2)
const filePath = './components/'

let argsStr = args.join(',')
// 是否强制更新，忽略ignoresMap
const isForce = argsStr.indexOf('!') !== -1
argsStr = argsStr.replace('!', '')
// 是否忽略入口，index.zh-CN.md 不包含 +  = true
const isIgnoreIndex = argsStr.indexOf('+') === -1 && !isForce
argsStr = argsStr.replace('+', '')
args = argsStr.split(',')
// 是否忽略 demo/basic.md，default:true
const index = args.findIndex(i => i === 'true' || i === 'false')
const isIgnoreBasic = index > -1 ? String(args.splice(index, 1)) : 'true'
// 传入的后缀名
let sufName = args.find(s => s !== 'true' || s !== 'false')

const keys = Object.keys(ignoresMap)
const ignoreSet = new Set([])

const readdir = path => new Promise((resolve, reject) => {
  fs.readdir(path, (err, files) => {
    err ? reject(err) : resolve(files)
  })
})

const rename = (oldPath, newPath) => new Promise((resolve, reject) => {
  fs.rename(oldPath, newPath, err => {
    err ? reject(err) : resolve()
  })
})


readdir(filePath).then(async components => {
  // 忽略_开头的文件夹和index.tsx
  const componentsDir = components.filter(component => !component.startsWith('_') && !component.includes('.'))
  componentsDir.forEach(dir => {
    // 入口文件 修改index.zh-CN.md必须同时修改demo目录
    fs.existsSync(filePath + dir) && readdir(filePath + dir).then(files => {
      files.forEach(file => {
        const oldPath = filePath + dir + '/' + file
        let [fileName, midName, suffixName] = file.split('.')
        !isForce && keys.includes(dir) && ignoresMap[dir].includes('index') && ignoreSet.add(oldPath)
        // demo 文件夹
        if (/_?demo$/.test(fileName)) {
          const newPath = `${filePath + dir}/${sufName === 'md' ? 'demo' : '_demo'}`
          // 修改 demo 文件夹
          if (!isIgnoreIndex && (newPath !== oldPath) && !ignoreSet.has(oldPath)) {
            try {
              fs.renameSync(oldPath, newPath)
              console.log('\x1B[30;42m Successfully modified \x1B[0m' + `\x1B[37m ${oldPath} \x1B[0m` + '\x1B[1m -> \x1B[0m' + `\x1B[36m ${newPath} \x1B[0m`)
            } catch (e) {
              console.log(e)
            }
          }

          // demo 目录下文件
          const demoDirs = [filePath + dir + '/demo/', filePath + dir + '/_demo/']
          demoDirs.forEach(demoDir => {
            fs.existsSync(demoDir) && readdir(demoDir).then(files => {
              // 是否忽略 basic
              isIgnoreIndex && isIgnoreBasic === 'true' && ignoreSet.add(demoDir + 'basic.md')
              files.forEach(file => {
                let [fileName, suffixName] = file.split('.')
                suffixName = suffixName === 'md' ? (sufName || 'bak') : (sufName || 'md')
                const oldPath = demoDir + file
                const newPath = demoDir + fileName + '.' + suffixName
                // 检查 key
                if (!isForce && keys.includes(dir)) {
                  keys.forEach(key => {
                    key === dir && (ignoresMap[key].includes('demo') || ignoresMap[key].includes(fileName)) && ignoreSet.add(oldPath)
                  })
                }
                (newPath !== oldPath) && !ignoreSet.has(oldPath) && rename(oldPath, newPath).then(() => console.log('\x1B[30;42m Successfully modified \x1B[0m' + `\x1B[37m ${oldPath} \x1B[0m` + '\x1B[1m -> \x1B[0m' + `\x1B[36m ${newPath} \x1B[0m`)).catch(e => console.log(e))
              })
            })
          })
        }


        // index.zh-CN.md
        if (suffixName && midName.includes('-')) {
          // 设置默认后缀名
          suffixName = suffixName === 'md' ? (sufName || 'bak') : (sufName || 'md')
          const newPath = filePath + dir + `/${fileName}.${midName}.` + suffixName
          newPath !== oldPath && !ignoreSet.has(oldPath) && rename(oldPath, newPath).then(() => console.log('\x1B[30;42m Successfully modified \x1B[0m' + `\x1B[37m ${oldPath} \x1B[0m` + '\x1B[1m -> \x1B[0m' + `\x1B[36m ${newPath} \x1B[0m`)).catch(e => console.log(e))
        }
      })
    })
  })
})
